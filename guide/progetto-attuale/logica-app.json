{
  "last_update": "2025-08-30T18:03:12Z",

  "task_completed": "FN-11 - Implementazione Selettore Lega",
  "feature_logic": {
    "feature_name": "Selezione Dinamica della Lega",
    "summary": "Implementa una funzionalità che permette agli utenti che partecipano a più leghe di passare da una all'altra in modo dinamico. La lega selezionata viene salvata come preferenza per l'utente e l'intera interfaccia dell'applicazione si aggiorna per mostrare i dati (aste, budget, rose) relativi alla lega attiva.",
    "architectural_pattern": "La funzionalità si basa su un custom hook di React (`useLeague`) che astrae la logica di stato. Questo hook gestisce la lega correntemente selezionata, la persiste (es. nel localStorage) e la fornisce al resto dell'applicazione. Un componente dedicato (`LeagueSelector`) viene inserito nella barra di navigazione per permettere all'utente di interagire con questo stato.",
    "user_flow": [
      "1. L'utente, membro di più leghe, visualizza la barra di navigazione (`navbar`).",
      "2. Nella navbar è presente il nuovo componente `LeagueSelector`, che mostra la lega attualmente attiva.",
      "3. L'utente clicca sul selettore, che mostra un menu a tendina con l'elenco di tutte le leghe a cui partecipa.",
      "4. L'utente seleziona una nuova lega dall'elenco.",
      "5. L'hook `useLeague` aggiorna lo stato globale dell'applicazione con il nuovo ID della lega.",
      "6. Tutti i componenti che dipendono dalla lega attiva (es. la pagina delle aste, il budget) si ri-renderizzano automaticamente per mostrare i dati pertinenti alla nuova lega selezionata."
    ],
    "core_components_interaction": {
      "src/hooks/useLeague.ts": "Nuovo hook che rappresenta il cuore della logica. Gestisce lo stato della lega attiva, si occupa di leggerlo/scriverlo (es. da localStorage) e fornisce l'ID della lega corrente e la funzione per cambiarlo.",
      "src/components/league/LeagueSelector.tsx": "Nuovo componente UI che recupera la lista delle leghe dell'utente e le visualizza in un selettore. Utilizza l'hook `useLeague` per mostrare la selezione corrente e per aggiornarla.",
      "src/components/navbar.tsx": "Modificata per includere e renderizzare il componente `LeagueSelector`, rendendo la funzionalità accessibile da qualsiasi punto dell'applicazione.",
      "src/app/auctions/AuctionPageContent.tsx": "Componente chiave che è stato modificato per utilizzare l'hook `useLeague`. Invece di ricevere un ID di lega statico, ora lo ottiene dinamicamente dall'hook, ricaricando i dati dell'asta ogni volta che l'utente cambia lega."
    },
    "database_interactions": [
      {
        "table": "league_participants",
        "operation": "SELECT",
        "description": "Recupera l'elenco di tutte le leghe a cui un utente è iscritto per poterle mostrare nel selettore. Solitamente in join con `auction_leagues` per ottenere i nomi delle leghe."
      }
    ]
  },
  "penalty_system_logic": {
    "feature_name": "Sistema di Compliance e Penalità Automatiche",
    "summary": "Implementazione di un sistema che monitora la compliance della rosa degli utenti e applica automaticamente penalità in crediti se l'utente rimane non-compliant oltre un periodo di grazia. Le penalità vengono applicate direttamente al budget dell'utente e registrate come transazioni.",
    "architectural_pattern": "La logica è integrata nella funzione `checkAndRecordCompliance` del servizio `penalty.service.ts`. Questa funzione viene invocata in vari punti dell'applicazione (es. login, eventi d'asta) e ora include un meccanismo per verificare la scadenza del grace period e applicare le penalità in modo sincrono all'interno della transazione database.",
    "user_flow": [
      "1. L'utente effettua il login o interagisce con un'asta, attivando un controllo di compliance.",
      "2. Se l'utente non è compliant, un timer di grace period di 1 ora viene avviato/aggiornato.",
      "3. Se, al successivo controllo di compliance (dopo il login o un evento), il grace period è scaduto e l'utente è ancora non-compliant, viene applicata una penalità di 5 crediti.",
      "4. La penalità viene sottratta dal `current_budget` dell'utente e registrata nella tabella `budget_transactions`.",
      "5. Le penalità sono limitate a un massimo di 25 crediti totali per utente per lega.",
      "6. Se l'utente diventa compliant, il timer e il ciclo di penalità vengono resettati."
    ],
    "core_components_interaction": {
      "src/lib/db/services/penalty.service.ts": "La funzione `checkAndRecordCompliance` è stata modificata per includere la logica di applicazione delle penalità. Questa funzione è il punto centrale per la gestione dello stato di compliance e l'applicazione delle penalità.",
      "src/lib/db/services/bid.service.ts": "Invoca `checkAndRecordCompliance` quando un utente viene superato in un'asta o quando un'asta si conclude senza vittoria, per verificare immediatamente lo stato di compliance."
    },
    "database_interactions": [
      {
        "table": "user_league_compliance_status",
        "operation": "SELECT, INSERT, UPDATE",
        "description": "Memorizza lo stato di compliance dell'utente per lega, inclusi il timer di inizio del grace period, l'ultima penalità applicata e il conteggio delle penalità nel ciclo corrente."
      },
      {
        "table": "league_participants",
        "operation": "UPDATE",
        "description": "Il `current_budget` dell'utente viene ridotto quando viene applicata una penalità."
      },
      {
        "table": "budget_transactions",
        "operation": "INSERT, SELECT",
        "description": "Registra ogni penalità applicata come una transazione di tipo `penalty_requirement`. Viene anche usata per calcolare il totale delle penalità già applicate."
      }
    ]
  },
  "scheduler_system_logic": {
    "feature_name": "Scheduler per Task Asincroni",
    "summary": "Implementa un sistema di scheduling centralizzato per eseguire task periodici in background, garantendo che operazioni critiche come la chiusura delle aste e la gestione dei timer vengano eseguite in modo tempestivo e affidabile.",
    "architectural_pattern": "Un processo singleton basato su `setInterval` viene avviato insieme al server Socket.IO. Questo scheduler esegue una funzione aggregatrice (`runBackgroundTasks`) a intervalli regolari (attualmente ogni 2 secondi). Questa funzione, a sua volta, invoca i vari servizi necessari (es. `processExpiredAuctionsAndAssignPlayers`).",
    "user_flow": [
      "1. L'applicazione si avvia, e con essa il server Socket.IO.",
      "2. Il server Socket.IO importa e avvia lo scheduler (`startScheduler`).",
      "3. Lo scheduler inizia immediatamente a eseguire `runBackgroundTasks` e poi ripete l'operazione ogni 2 secondi.",
      "4. Ad ogni esecuzione, `runBackgroundTasks` chiama la funzione per processare le aste scadute.",
      "5. Se un'asta è scaduta (es. l'asta di Caprile), viene processata, il suo stato aggiornato a 'sold', e le notifiche vengono inviate ai client."
    ],
    "core_components_interaction": {
      "src/lib/scheduler.ts": "File centrale che contiene la logica dello scheduler, inclusa la funzione `startScheduler` e `runBackgroundTasks`.",
      "src/lib/db/services/bid.service.ts": "Contiene la logica di business per processare le aste scadute (`processExpiredAuctionsAndAssignPlayers`), che viene ora chiamata dallo scheduler.",
      "socket-server.ts": "Punto di ingresso che avvia lo scheduler, assicurando che sia sempre attivo quando l'applicazione è in esecuzione."
    },
    "database_interactions": [
      {
        "table": "auctions",
        "operation": "SELECT, UPDATE",
        "description": "Lo scheduler interroga la tabella per trovare aste con `status = 'active'` e `scheduled_end_time <= now`, e poi aggiorna il loro stato a 'sold'."
      }
    ]
  }
}
