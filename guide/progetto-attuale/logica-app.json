{
  "last_update": "2025-12-05T20:30:00Z",
  "task_completed": "FN-23 - Bulk Link Player Photos",
  "feature_logic": {
    "feature_name": "Selezione Dinamica della Lega",
    "summary": "Implementa una funzionalità che permette agli utenti che partecipano a più leghe di passare da una all'altra in modo dinamico. La lega selezionata viene salvata come preferenza per l'utente e l'intera interfaccia dell'applicazione si aggiorna per mostrare i dati (aste, budget, rose) relativi alla lega attiva.",
    "architectural_pattern": "La funzionalità si basa su un custom hook di React (`useLeague`) che astrae la logica di stato. Questo hook gestisce la lega correntemente selezionata, la persiste (es. nel localStorage) e la fornisce al resto dell'applicazione. Un componente dedicato (`LeagueSelector`) viene inserito nella barra di navigazione per permettere all'utente di interagire con questo stato.",
    "user_flow": [
      "1. L'utente, membro di più leghe, visualizza la barra di navigazione (`navbar`).",
      "2. Nella navbar è presente il nuovo componente `LeagueSelector`, che mostra la lega attualmente attiva.",
      "3. L'utente clicca sul selettore, che mostra un menu a tendina con l'elenco di tutte le leghe a cui partecipa.",
      "4. L'utente seleziona una nuova lega dall'elenco.",
      "5. L'hook `useLeague` aggiorna lo stato globale dell'applicazione con il nuovo ID della lega.",
      "6. Tutti i componenti che dipendono dalla lega attiva (es. la pagina delle aste, il budget) si ri-renderizzano automaticamente per mostrare i dati pertinenti alla nuova lega selezionata."
    ],
    "core_components_interaction": {
      "src/hooks/useLeague.ts": "Nuovo hook che rappresenta il cuore della logica. Gestisce lo stato della lega attiva, si occupa di leggerlo/scriverlo (es. da localStorage) e fornisce l'ID della lega corrente e la funzione per cambiarlo.",
      "src/components/league/LeagueSelector.tsx": "Nuovo componente UI che recupera la lista delle leghe dell'utente e le visualizza in un selettore. Utilizza l'hook `useLeague` per mostrare la selezione corrente e per aggiornarla.",
      "src/components/navbar.tsx": "Modificata per includere e renderizzare il componente `LeagueSelector`, rendendo la funzionalità accessibile da qualsiasi punto dell'applicazione.",
      "src/app/auctions/AuctionPageContent.tsx": "Componente chiave che è stato modificato per utilizzare l'hook `useLeague`. Invece di ricevere un ID di lega statico, ora lo ottiene dinamicamente dall'hook, ricaricando i dati dell'asta ogni volta che l'utente cambia lega."
    },
    "database_interactions": [
      {
        "table": "league_participants",
        "operation": "SELECT",
        "description": "Recupera l'elenco di tutte le leghe a cui un utente è iscritto per poterle mostrare nel selettore. Solitamente in join con `auction_leagues` per ottenere i nomi delle leghe."
      }
    ]
  },
  "penalty_system_logic": {
    "feature_name": "Sistema di Compliance e Penalità Automatiche",
    "summary": "Implementazione di un sistema che monitora la compliance della rosa degli utenti e applica automaticamente penalità in crediti se l'utente rimane non-compliant oltre un periodo di grazia. Le penalità vengono applicate direttamente al budget dell'utente e registrate come transazioni.",
    "architectural_pattern": "La logica è integrata nella funzione `checkAndRecordCompliance` del servizio `penalty.service.ts`. Questa funzione viene invocata in vari punti dell'applicazione (es. login, eventi d'asta) e ora include un meccanismo per verificare la scadenza del grace period e applicare le penalità in modo sincrono all'interno della transazione database.",
    "user_flow": [
      "1. L'utente effettua il login o interagisce con un'asta, attivando un controllo di compliance.",
      "2. Se l'utente non è compliant, un timer di grace period di 1 ora viene avviato/aggiornato.",
      "3. Se, al successivo controllo di compliance (dopo il login o un evento), il grace period è scaduto e l'utente è ancora non-compliant, viene applicata una penalità di 5 crediti.",
      "4. La penalità viene sottratta dal `current_budget` dell'utente e registrata nella tabella `budget_transactions`.",
      "5. Le penalità sono limitate a un massimo di 25 crediti totali per utente per lega.",
      "6. Se l'utente diventa compliant, il timer e il ciclo di penalità vengono resettati."
    ],
    "core_components_interaction": {
      "src/lib/db/services/penalty.service.ts": "La funzione `checkAndRecordCompliance` è stata modificata per includere la logica di applicazione delle penalità. Questa funzione è il punto centrale per la gestione dello stato di compliance e l'applicazione delle penalità.",
      "src/lib/db/services/bid.service.ts": "Invoca `checkAndRecordCompliance` quando un utente viene superato in un'asta o quando un'asta si conclude senza vittoria, per verificare immediatamente lo stato di compliance."
    },
    "database_interactions": [
      {
        "table": "user_league_compliance_status",
        "operation": "SELECT, INSERT, UPDATE",
        "description": "Memorizza lo stato di compliance dell'utente per lega, inclusi il timer di inizio del grace period, l'ultima penalità applicata e il conteggio delle penalità nel ciclo corrente."
      },
      {
        "table": "league_participants",
        "operation": "UPDATE",
        "description": "Il `current_budget` dell'utente viene ridotto quando viene applicata una penalità."
      },
      {
        "table": "budget_transactions",
        "operation": "INSERT, SELECT",
        "description": "Registra ogni penalità applicata come una transazione di tipo `penalty_requirement`. Viene anche usata per calcolare il totale delle penalità già applicate."
      }
    ]
  },
  "scheduler_system_logic": {
    "feature_name": "Scheduler per Task Asincroni",
    "summary": "Implementa un sistema di scheduling centralizzato per eseguire task periodici in background, garantendo che operazioni critiche come la chiusura delle aste e la gestione dei timer vengano eseguite in modo tempestivo e affidabile.",
    "architectural_pattern": "Un processo singleton basato su `setInterval` viene avviato insieme al server Socket.IO. Questo scheduler esegue una funzione aggregatrice (`runBackgroundTasks`) a intervalli regolari (attualmente ogni 2 secondi). Questa funzione, a sua volta, invoca i vari servizi necessari (es. `processExpiredAuctionsAndAssignPlayers`).",
    "user_flow": [
      "1. L'applicazione si avvia, e con essa il server Socket.IO.",
      "2. Il server Socket.IO importa e avvia lo scheduler (`startScheduler`).",
      "3. Lo scheduler inizia immediatamente a eseguire `runBackgroundTasks` e poi ripete l'operazione ogni 2 secondi.",
      "4. Ad ogni esecuzione, `runBackgroundTasks` chiama la funzione per processare le aste scadute.",
      "5. Se un'asta è scaduta (es. l'asta di Caprile), viene processata, il suo stato aggiornato a 'sold', e le notifiche vengono inviate ai client."
    ],
    "core_components_interaction": {
      "src/lib/scheduler.ts": "File centrale che contiene la logica dello scheduler, inclusa la funzione `startScheduler` e `runBackgroundTasks`.",
      "src/lib/db/services/bid.service.ts": "Contiene la logica di business per processare le aste scadute (`processExpiredAuctionsAndAssignPlayers`), che viene ora chiamata dallo scheduler.",
      "socket-server.ts": "Punto di ingresso che avvia lo scheduler, assicurando che sia sempre attivo quando l'applicazione è in esecuzione."
    },
    "database_interactions": [
      {
        "table": "auctions",
        "operation": "SELECT, UPDATE",
        "description": "Lo scheduler interroga la tabella per trovare aste con `status = 'active'` e `scheduled_end_time <= now`, e poi aggiorna il loro stato a 'sold'."
      }
    ]
  },
  "ssr_implementation": {
    "feature_name": "Server-Side Rendering per Pagina Aste",
    "summary": "Implementazione del rendering lato server (SSR) per la pagina principale delle aste per migliorare le performance di caricamento iniziale e la SEO. I dati iniziali (manager, aste attive, budget, stati utente) vengono recuperati sul server e passati come props al componente client.",
    "architectural_pattern": "Server Component (`page.tsx`) che esegue il data fetching parallelo tramite servizi DB dedicati e passa i dati serializzati al Client Component (`AuctionPageContent.tsx`). Il Client Component inizializza il suo stato con questi dati e poi si sottoscrive agli aggiornamenti real-time via Socket.IO.",
    "technical_details": [
      "Backend (auction-league.service.ts): Aggiunta funzione `getLeagueManagersWithRosters` per aggregare dati manager, rose e aste attive.",
      "Backend (auction-states.service.ts): Aggiunta funzione `getUserAuctionStates` per recuperare gli stati d'asta specifici dell'utente.",
      "Frontend (page.tsx): Recupero dati server-side con gestione errori e redirect se necessario.",
      "Frontend (AuctionPageContent.tsx): Aggiornato per accettare `initial*` props e inizializzare `useState` con essi. Risolti conflitti di tipo tra interfacce server e client."
    ]
  },
  "auction_abandonment_logic": {
    "feature_name": "Abbandono Asta e Timer di Risposta",
    "summary": "Permette agli utenti di abbandonare volontariamente un'asta quando vengono superati, invece di attendere la scadenza del timer. Questo libera immediatamente i crediti bloccati e applica un cooldown di 48 ore per quel giocatore.",
    "architectural_pattern": "Gestito tramite l'endpoint `/api/leagues/[id]/players/[id]/response-action` e il servizio `response-timer.service.ts`. L'azione 'fold' triggera la funzione `abandonAuction`.",
    "user_flow": [
      "1. L'utente riceve una notifica di superamento offerta.",
      "2. Apre il modale di risposta e clicca su 'Abbandona'.",
      "3. Il frontend invia una richiesta POST con action='fold'.",
      "4. Il backend verifica che l'utente abbia un timer attivo e non sia già in cooldown.",
      "5. Se valido, l'asta viene abbandonata per l'utente, i crediti sbloccati, e viene registrata una transazione 'auction_abandoned'.",
      "6. Viene applicato un cooldown di 48 ore per quel giocatore."
    ],
    "database_interactions": [
      {
        "table": "budget_transactions",
        "operation": "INSERT",
        "description": "Registra l'abbandono con tipo 'auction_abandoned'. Richiede `auction_league_id`."
      },
      {
        "table": "user_auction_cooldowns",
        "operation": "INSERT",
        "description": "Crea un record di cooldown per l'utente e il giocatore."
      }
    ]
  },
  "infinite_loop_fix": {
    "feature_name": "Ottimizzazione Loop Notifiche Compliance",
    "summary": "Risoluzione di un bug critico che causava un loop infinito di notifiche e riconnessioni socket. Il fix coinvolge sia il backend (emissione condizionale) che il frontend (gestione dipendenze useEffect).",
    "architectural_pattern": "Backend: Conditional Event Emission. Frontend: Ref Ref-based State Tracking.",
    "technical_details": [
      "Frontend (AuctionPageContent.tsx): Sostituito `useState` con `useRef` per tracciare l'ultima notifica ricevuta, rimuovendo la dipendenza che causava il re-rendering e la riconnessione al socket ad ogni evento."
    ]
  },
  "default_bid_logic_fix": {
    "feature_name": "Correzione Default Bid Amount",
    "summary": "Risolto un problema per cui il modale di offerta rapida (`QuickBidModal`) non mostrava il valore corretto (offerta attuale + 1) quando si tentava di rilanciare su un'asta attiva avviata da un altro utente.",
    "technical_details": [
      "Backend (player.service.ts): Aggiornata la query `getPlayers` per includere il campo `current_highest_bid_amount` dalla tabella `auctions` come `current_bid` per i giocatori in stato 'active_auction'.",
      "Frontend (CallPlayerInterface.tsx): Aggiornata l'interfaccia `ApiPlayer` e la funzione di mapping `refreshPlayersData` per leggere `current_bid` dall'API e passarlo allo stato del componente.",
      "Frontend (QuickBidModal.tsx): Aggiornata la logica di inizializzazione per usare `currentBid + 1` come valore di default quando disponibile."
    ]
  },
  "socket_room_fix": {
    "feature_name": "Fix Connessione Stanze Socket.IO",
    "summary": "Risolto un problema critico per cui il client non riceveva eventi real-time perché il server Socket.IO ascoltava eventi con nomi diversi ('join-league-room') da quelli emessi dal client ('join-room').",
    "technical_details": [
      "Backend (socket-server.ts): Aggiunti handler generici `join-room` e `leave-room` per supportare le chiamate del client.",
      "Frontend (AuctionPageContent.tsx): Corretta la gestione della risposta di `fetchUserAuctionStates` per prevenire crash client-side."
    ]
  },
  "ui_optimization": {
    "feature_name": "Ottimizzazione Modale Avvio Asta",
    "summary": "Migliorata la reattività dell'interfaccia rimuovendo un refresh dati bloccante prima dell'apertura del modale di avvio asta.",
    "technical_details": [
      "Frontend (CallPlayerInterface.tsx): Rimossa la chiamata `refreshPlayersData()` prima di `setIsStartAuctionModalOpen(true)`. Il modale ora si apre istantaneamente usando i dati locali."
    ]
  },
  "server_actions_implementation": {
    "feature_name": "Server Actions per Interazioni Asta",
    "summary": "Migrazione delle interazioni critiche dell'asta (offerte, creazione asta, abbandono) dalle API Routes alle Server Actions di Next.js. Questo migliora la type safety, riduce il codice client-side e centralizza la logica di validazione e gestione errori.",
    "architectural_pattern": "Le Server Actions (`placeBidAction`, `abandonAuctionAction`) sono definite in `src/lib/actions/auction.actions.ts`. I componenti client (`AuctionPageContent`, `CallPlayerInterface`, `QuickBidModal`) importano e invocano direttamente queste funzioni asincrone, gestendo il risultato tipizzato (`ActionResponse`).",
    "technical_details": [
      "Server Action (placeBidAction): Gestisce sia la creazione di nuove aste che le offerte su aste esistenti, incapsulando la logica di business di `bid.service.ts`.",
      "Server Action (abandonAuctionAction): Gestisce l'abbandono di un'asta attiva.",
      "Client Integration: I componenti UI invocano le actions e gestiscono i feedback (successo/errore) tramite toast notifications, eliminando la necessità di `fetch` manuali."
    ]
  },
  "budget_verification_logic": {
    "feature_name": "Verifica e Debug del Budget",
    "summary": "Implementazione di strumenti di debug e correzione di bug critici nella gestione dei crediti bloccati (`locked_credits`). Il sistema garantisce che la somma di `disponibili + bloccati + spesi` sia sempre uguale al budget iniziale meno le penalità.",
    "architectural_pattern": "API Endpoint protetto (`/api/debug/budget-verification`) accessibile solo agli admin, che esegue query SQL dirette per aggregare i dati da diverse tabelle. Pagina di debug (`/debug/budget`) per visualizzare i risultati.",
    "technical_details": [
      "Bug Fix (Double Unlock): Risolto un problema in `bid.service.ts` dove i crediti degli auto-bid venivano sbloccati due volte (una volta quando superati, e di nuovo alla chiusura dell'asta), causando valori negativi.",
      "Bug Fix (Abandon Unlock): Risolto un problema in `auction-states.service.ts` dove l'abbandono di un'asta sbloccava erroneamente crediti per offerte manuali (che non bloccano crediti) o duplicava lo sblocco per auto-bid.",
      "Verifica: La formula `Iniziale = Disponibili + Bloccati + Spesi (giocatori) + Penalità` è ora verificata e consistente."
    ],
    "database_interactions": [
      {
        "table": "league_participants",
        "operation": "SELECT, UPDATE",
        "description": "Lettura per verifica budget e aggiornamento `locked_credits` con controlli di sicurezza (`MAX(0, ...)`)."
      },
      {
        "table": "auto_bids",
        "operation": "SELECT",
        "description": "Verifica dello stato `is_active` per prevenire doppi sblocchi."
      }
    ]
  },
  "privacy_logic": {
    "feature_name": "Privacy dei Dati Sensibili (Locked Credits)",
    "summary": "Implementazione di regole di visibilità per impedire agli utenti di vedere i crediti bloccati (e quindi dedurre le auto-bid attive) degli avversari.",
    "architectural_pattern": "Sanitizzazione dei dati a livello API e SSR, e logica condizionale nella UI.",
    "technical_details": [
      "API (/api/leagues/[id]/managers): I campi `locked_credits` vengono impostati a 0 per tutti gli utenti diversi dal richiedente.",
      "SSR (page.tsx): I dati iniziali dei manager vengono sanitizzati prima di essere passati al Client Component.",
      "UI (ManagerColumn.tsx): Se `!isCurrentUser`, il campo 'Bloccati' mostra '-' e il campo 'Disponibili' mostra il 'Residuo Teorico' (Totale - Spesi) invece del reale disponibile."
    ]
  },
  "players_page_refinement": {
    "feature_name": "Refactoring UI Pagina Giocatori e Ottimizzazione Performance",
    "summary": "Riprogettazione dell'interfaccia di ricerca giocatori per migliorare l'usabilità e l'efficienza dello spazio, e ottimizzazione critica delle performance di caricamento.",
    "architectural_pattern": "UI: Sostituzione di filtri a griglia con una Toolbar compatta (Popover + Sheet). Performance: Batch data fetching per eliminare query N+1.",
    "technical_details": [
      "UI (PlayerFilterBar.tsx): Nuovo componente compatto che utilizza Popover per i filtri comuni e uno Sheet laterale per i filtri avanzati, risparmiando il 60% di spazio verticale.",
      "UI (PlayerSearchCard.tsx): Adozione del sistema colori pastello (coerente con la pagina Aste) per i ruoli dei giocatori.",
      "Performance (API): Risolto problema N+1 query nell'endpoint `/api/leagues/[id]/players-with-status`. I cooldown utente vengono ora recuperati in un'unica query batch invece che per ogni singolo giocatore, riducendo le query da N+4 a 5 costanti."
    ],
    "database_interactions": [
      {
        "table": "user_player_preferences",
        "operation": "SELECT",
        "description": "Query batch ottimizzata per recuperare tutti i cooldown attivi dell'utente in una sola chiamata."
      }
    ]
  },
  "dashboard_ui_improvements": {
    "feature_name": "Miglioramento UI Dashboard Aste",
    "summary": "Restyling completo della dashboard delle aste per migliorare l'estetica e l'esperienza utente. Introdotto un design 'glassmorphism', una nuova palette colori pastello per i ruoli, e animazioni per gli aggiornamenti in tempo reale.",
    "architectural_pattern": "UI-only update: utilizzo di Tailwind CSS e `tailwindcss-animate` per transizioni e animazioni senza aggiungere nuove dipendenze.",
    "technical_details": [
      "ManagerColumn.tsx: Aggiornato con card in stile glassmorphism, nuovi colori per i ruoli (Amber, Emerald, Sky, Rose) e dashboard budget ridisegnata.",
      "AuctionRealtimeDisplay.tsx: Aggiunte animazioni 'pop' al cambio offerta e migliorata la visualizzazione del timer e dello stato 'Sold'.",
      "BiddingInterface.tsx: Migliorato il feedback visivo dei pulsanti di offerta rapida."
    ]
  },
  "players_page_pagination": {
    "feature_name": "Ottimizzazione Pagina Giocatori (Paginazione Server-Side)",
    "summary": "Implementazione della paginazione e del filtraggio lato server per la pagina di ricerca giocatori, riducendo drasticamente il carico iniziale e migliorando le performance.",
    "architectural_pattern": "API Paginata + Frontend State Management. L'API accetta parametri `page`, `limit` e filtri, restituendo solo il sottoinsieme di dati richiesto.",
    "technical_details": [
      "API (/api/leagues/[id]/players-with-status): Aggiornata per supportare paginazione (LIMIT/OFFSET) e filtri dinamici (WHERE clause).",
      "Frontend (PlayerSearchInterface.tsx): Implementata gestione stato paginazione, debouncing della ricerca e aggiornamento dati al cambio pagina/filtri.",
      "Linting: Risolti errori di linting (prefer-const, prefer-template, no-explicit-any) nell'API route."
    ],
    "database_interactions": [
      {
        "table": "players",
        "operation": "SELECT",
        "description": "Query principale con LIMIT/OFFSET e filtri dinamici."
      },
      {
        "table": "players",
        "operation": "COUNT",
        "description": "Query separata per ottenere il numero totale di risultati per la paginazione."
      }
    ]
  },
  "optimization_logic": {
    "feature_name": "Next.js 16 Readiness & React Compiler",
    "summary": "Attivazione sperimentale del React Compiler (disponibile in Next.js 15) per ottimizzare automaticamente il rendering dei componenti e preparare il codice per Next.js 16.",
    "architectural_pattern": "Configurazione build-time in `next.config.mjs`.",
    "technical_details": [
      "Configuration: Abilitato `experimental.reactCompiler` in `next.config.mjs`.",
      "Dependencies: Aggiunto `babel-plugin-react-compiler` come devDependency.",
      "Verification: Build di produzione verificata con successo."
    ]
  },
  "empty_db_logic": {
    "feature_name": "Gestione Database Giocatori Vuoto",
    "summary": "Implementa un controllo nel frontend per rilevare se il database dei giocatori è vuoto e mostra un messaggio di errore chiaro all'utente, prevenendo confusione o loop di caricamento.",
    "technical_details": [
      "Frontend (CallPlayerInterface.tsx): Aggiunto stato `hasNoPlayers` e logica condizionale per mostrare un alert se l'API restituisce una lista vuota."
    ]
  }
}
