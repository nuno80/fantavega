{
  "last_update": "2025-08-30T18:03:12Z",
  "task_completed": "FN-11 - Implementazione Selettore Lega",
  "feature_logic": {
    "feature_name": "Selezione Dinamica della Lega",
    "summary": "Implementa una funzionalità che permette agli utenti che partecipano a più leghe di passare da una all'altra in modo dinamico. La lega selezionata viene salvata come preferenza per l'utente e l'intera interfaccia dell'applicazione si aggiorna per mostrare i dati (aste, budget, rose) relativi alla lega attiva.",
    "architectural_pattern": "La funzionalità si basa su un custom hook di React (`useLeague`) che astrae la logica di stato. Questo hook gestisce la lega correntemente selezionata, la persiste (es. nel localStorage) e la fornisce al resto dell'applicazione. Un componente dedicato (`LeagueSelector`) viene inserito nella barra di navigazione per permettere all'utente di interagire con questo stato.",
    "user_flow": [
      "1. L'utente, membro di più leghe, visualizza la barra di navigazione (`navbar`).",
      "2. Nella navbar è presente il nuovo componente `LeagueSelector`, che mostra la lega attualmente attiva.",
      "3. L'utente clicca sul selettore, che mostra un menu a tendina con l'elenco di tutte le leghe a cui partecipa.",
      "4. L'utente seleziona una nuova lega dall'elenco.",
      "5. L'hook `useLeague` aggiorna lo stato globale dell'applicazione con il nuovo ID della lega.",
      "6. Tutti i componenti che dipendono dalla lega attiva (es. la pagina delle aste, il budget) si ri-renderizzano automaticamente per mostrare i dati pertinenti alla nuova lega selezionata."
    ],
    "core_components_interaction": {
      "src/hooks/useLeague.ts": "Nuovo hook che rappresenta il cuore della logica. Gestisce lo stato della lega attiva, si occupa di leggerlo/scriverlo (es. da localStorage) e fornisce l'ID della lega corrente e la funzione per cambiarlo.",
      "src/components/league/LeagueSelector.tsx": "Nuovo componente UI che recupera la lista delle leghe dell'utente e le visualizza in un selettore. Utilizza l'hook `useLeague` per mostrare la selezione corrente e per aggiornarla.",
      "src/components/navbar.tsx": "Modificata per includere e renderizzare il componente `LeagueSelector`, rendendo la funzionalità accessibile da qualsiasi punto dell'applicazione.",
      "src/app/auctions/AuctionPageContent.tsx": "Componente chiave che è stato modificato per utilizzare l'hook `useLeague`. Invece di ricevere un ID di lega statico, ora lo ottiene dinamicamente dall'hook, ricaricando i dati dell'asta ogni volta che l'utente cambia lega."
    },
    "database_interactions": [
      {
        "table": "league_participants",
        "operation": "SELECT",
        "description": "Recupera l'elenco di tutte le leghe a cui un utente è iscritto per poterle mostrare nel selettore. Solitamente in join con `auction_leagues` per ottenere i nomi delle leghe."
      }
    ]
  },
  "penalty_system_logic": {
    "feature_name": "Sistema di Compliance e Penalità Automatiche",
    "summary": "Implementazione di un sistema che monitora la compliance della rosa degli utenti e applica automaticamente penalità in crediti se l'utente rimane non-compliant oltre un periodo di grazia. Le penalità vengono applicate direttamente al budget dell'utente e registrate come transazioni.",
    "architectural_pattern": "La logica è integrata nella funzione `checkAndRecordCompliance` del servizio `penalty.service.ts`. Questa funzione viene invocata in vari punti dell'applicazione (es. login, eventi d'asta) e ora include un meccanismo per verificare la scadenza del grace period e applicare le penalità in modo sincrono all'interno della transazione database.",
    "user_flow": [
      "1. L'utente effettua il login o interagisce con un'asta, attivando un controllo di compliance.",
      "2. Se l'utente non è compliant, un timer di grace period di 1 ora viene avviato/aggiornato.",
      "3. Se, al successivo controllo di compliance (dopo il login o un evento), il grace period è scaduto e l'utente è ancora non-compliant, viene applicata una penalità di 5 crediti.",
      "4. La penalità viene sottratta dal `current_budget` dell'utente e registrata nella tabella `budget_transactions`.",
      "5. Le penalità sono limitate a un massimo di 25 crediti totali per utente per lega.",
      "6. Se l'utente diventa compliant, il timer e il ciclo di penalità vengono resettati."
    ],
    "core_components_interaction": {
      "src/lib/db/services/penalty.service.ts": "La funzione `checkAndRecordCompliance` è stata modificata per includere la logica di applicazione delle penalità. Questa funzione è il punto centrale per la gestione dello stato di compliance e l'applicazione delle penalità.",
      "src/lib/db/services/bid.service.ts": "Invoca `checkAndRecordCompliance` quando un utente viene superato in un'asta o quando un'asta si conclude senza vittoria, per verificare immediatamente lo stato di compliance."
    },
    "database_interactions": [
      {
        "table": "user_league_compliance_status",
        "operation": "SELECT, INSERT, UPDATE",
        "description": "Memorizza lo stato di compliance dell'utente per lega, inclusi il timer di inizio del grace period, l'ultima penalità applicata e il conteggio delle penalità nel ciclo corrente."
      },
      {
        "table": "league_participants",
        "operation": "UPDATE",
        "description": "Il `current_budget` dell'utente viene ridotto quando viene applicata una penalità."
      },
      {
        "table": "budget_transactions",
        "operation": "INSERT, SELECT",
        "description": "Registra ogni penalità applicata come una transazione di tipo `penalty_requirement`. Viene anche usata per calcolare il totale delle penalità già applicate."
      }
    ]
  },
  "scheduler_system_logic": {
    "feature_name": "Scheduler per Task Asincroni",
    "summary": "Implementa un sistema di scheduling centralizzato per eseguire task periodici in background, garantendo che operazioni critiche come la chiusura delle aste e la gestione dei timer vengano eseguite in modo tempestivo e affidabile.",
    "architectural_pattern": "Un processo singleton basato su `setInterval` viene avviato insieme al server Socket.IO. Questo scheduler esegue una funzione aggregatrice (`runBackgroundTasks`) a intervalli regolari (attualmente ogni 2 secondi). Questa funzione, a sua volta, invoca i vari servizi necessari (es. `processExpiredAuctionsAndAssignPlayers`).",
    "user_flow": [
      "1. L'applicazione si avvia, e con essa il server Socket.IO.",
      "2. Il server Socket.IO importa e avvia lo scheduler (`startScheduler`).",
      "3. Lo scheduler inizia immediatamente a eseguire `runBackgroundTasks` e poi ripete l'operazione ogni 2 secondi.",
      "4. Ad ogni esecuzione, `runBackgroundTasks` chiama la funzione per processare le aste scadute.",
      "5. Se un'asta è scaduta (es. l'asta di Caprile), viene processata, il suo stato aggiornato a 'sold', e le notifiche vengono inviate ai client."
    ],
    "core_components_interaction": {
      "src/lib/scheduler.ts": "File centrale che contiene la logica dello scheduler, inclusa la funzione `startScheduler` e `runBackgroundTasks`.",
      "src/lib/db/services/bid.service.ts": "Contiene la logica di business per processare le aste scadute (`processExpiredAuctionsAndAssignPlayers`), che viene ora chiamata dallo scheduler.",
      "socket-server.ts": "Punto di ingresso che avvia lo scheduler, assicurando che sia sempre attivo quando l'applicazione è in esecuzione."
    },
    "database_interactions": [
      {
        "table": "auctions",
        "operation": "SELECT, UPDATE",
        "description": "Lo scheduler interroga la tabella per trovare aste con `status = 'active'` e `scheduled_end_time <= now`, e poi aggiorna il loro stato a 'sold'."
      }
    ]
  }
},
"auction_abandonment_logic": {
  "feature_name": "Abbandono Asta e Timer di Risposta",
  "summary": "Permette agli utenti di abbandonare volontariamente un'asta quando vengono superati, invece di attendere la scadenza del timer. Questo libera immediatamente i crediti bloccati e applica un cooldown di 48 ore per quel giocatore.",
  "architectural_pattern": "Gestito tramite l'endpoint `/api/leagues/[id]/players/[id]/response-action` e il servizio `response-timer.service.ts`. L'azione 'fold' triggera la funzione `abandonAuction`.",
  "user_flow": [
    "1. L'utente riceve una notifica di superamento offerta.",
    "2. Apre il modale di risposta e clicca su 'Abbandona'.",
    "3. Il frontend invia una richiesta POST con action='fold'.",
    "4. Il backend verifica che l'utente abbia un timer attivo e non sia già in cooldown.",
    "5. Se valido, l'asta viene abbandonata per l'utente, i crediti sbloccati, e viene registrata una transazione 'auction_abandoned'.",
    "6. Viene applicato un cooldown di 48 ore per quel giocatore."
  ],
  "database_interactions": [
    {
      "table": "budget_transactions",
      "operation": "INSERT",
      "description": "Registra l'abbandono con tipo 'auction_abandoned'. Richiede `auction_league_id`."
    },
    {
      "table": "user_auction_cooldowns",
      "operation": "INSERT",
      "description": "Crea un record di cooldown per l'utente e il giocatore."
    }
  ]
},
"infinite_loop_fix": {
  "feature_name": "Ottimizzazione Loop Notifiche Compliance",
  "summary": "Risoluzione di un bug critico che causava un loop infinito di notifiche e riconnessioni socket. Il fix coinvolge sia il backend (emissione condizionale) che il frontend (gestione dipendenze useEffect).",
  "architectural_pattern": "Backend: Conditional Event Emission. Frontend: Ref Ref-based State Tracking.",
  "technical_details": [
    "Frontend (AuctionPageContent.tsx): Sostituito `useState` con `useRef` per tracciare l'ultima notifica ricevuta, rimuovendo la dipendenza che causava il re-rendering e la riconnessione al socket ad ogni evento."
  ]
},
"default_bid_logic_fix": {
  "feature_name": "Correzione Default Bid Amount",
  "summary": "Risolto un problema per cui il modale di offerta rapida (`QuickBidModal`) non mostrava il valore corretto (offerta attuale + 1) quando si tentava di rilanciare su un'asta attiva avviata da un altro utente.",
  "technical_details": [
    "Backend (player.service.ts): Aggiornata la query `getPlayers` per includere il campo `current_highest_bid_amount` dalla tabella `auctions` come `current_bid` per i giocatori in stato 'active_auction'.",
    "Frontend (CallPlayerInterface.tsx): Aggiornata l'interfaccia `ApiPlayer` e la funzione di mapping `refreshPlayersData` per leggere `current_bid` dall'API e passarlo allo stato del componente.",
    "Frontend (QuickBidModal.tsx): Aggiornata la logica di inizializzazione per usare `currentBid + 1` come valore di default quando disponibile."
  ]
}
}
